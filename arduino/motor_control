#include<ros.h>
#include <docking/xyInput.h>
#include <docking/limit.h>

#define x_d 5   //cw+
#define x_mm 4  //clk+ 
#define y_d 3   //cw+
#define y_mm 2  //clk+

#define pulse 1000

#define y_limit_left 6 // at front
#define y_limit_right 7
#define x_limit_up 8
#define x_limit_down 9
ros::NodeHandle nh;

using docking::xyInput;
using docking::limit;

docking::limit limit_msg;

int angle(float degree,char xy){ // 각도로 이동
  if(degree>0)
    digitalWrite(3,HIGH);
  else{
    digitalWrite(3,LOW);
    degree = -1 * degree; 
  }
  float d=200*degree/360;
  for(int i=0;i<d;i++){
    digitalWrite(2,HIGH);//HIGH신호 입력
    delayMicroseconds(pulse);//1000 마이크로초 대기 600~
    digitalWrite(2,LOW);//LOW신호 입력
    delayMicroseconds(pulse);
  }
  return 1;  
}

int move_mm(int mm,char xy){ // mm 단위로 이동
  if(xy=='y'){   
    if(mm>0)
      digitalWrite(y_d,HIGH);
    else{
      digitalWrite(y_d,LOW);
      mm = -1 * mm; 
    }
    int dy = 100*mm;
    for(int i=0;i<dy;i++)
    {
      if(digitalRead(y_limit_left)== LOW && digitalRead(y_limit_right) == LOW)
       { 
         digitalWrite(y_mm,HIGH);//HIGH신호 입력
         delayMicroseconds(pulse);//1000 마이크로초 대기 600~
         digitalWrite(y_mm,LOW);//LOW신호 입력
         delayMicroseconds(pulse);
       }
       else break; 
    }
    return 1;
  }
  else if(xy=='x')
  {
    
    if(mm>0)
      digitalWrite(x_d,HIGH);
    else
    {
      digitalWrite(x_d,LOW);
      mm = -1 * mm; 
    }
    int dx = 100*mm;
    for(int i=0;i<dx;i++)
    {
      if(digitalRead(x_limit_up )== LOW && digitalRead(x_limit_down) == LOW )
        { 
          digitalWrite(x_mm,HIGH);//HIGH신호 입력
          delayMicroseconds(pulse);//1000 마이크로초 대기 600~
          digitalWrite(x_mm,LOW);//LOW신호 입력
          delayMicroseconds(pulse);
        }
       else break;
    }
    return 1;
 }
}


void motor_callback(const xyInput::Request & req, xyInput::Response & res)
{
      
     float x = req.x;
     float y = req.y;
     bool donex = 0;
     bool doney = 0;
     res.done = 0;
     
     if(x)
     {
        donex = move_mm(x,'x');
     }
     else
     {
        donex = 1;
      }
     if(y)
     {
        doney = move_mm(y,'y'); 
     }
     else
     {
        doney = 1;
     }
   
    if(donex== 1 && doney == 1)
     {
        res.done = 1;
        
     }
     else
     {
       res.done = 0;
     }
}

void limit_switch()
{
  if(digitalRead(x_limit_up)== HIGH)
  { 
    limit_msg.X_limit_up = 1;
  }
  else limit_msg.X_limit_up = 0;

   if(digitalRead(x_limit_down)== HIGH)
  { 
    limit_msg.X_limit_down = 1;
  }
  else limit_msg.X_limit_down = 0;

   if(digitalRead(y_limit_right)== HIGH)
  { 
    limit_msg.Y_limit_right = 1;
  }
  else limit_msg.Y_limit_right = 0;

   if(digitalRead(y_limit_left)== HIGH)
  { 
    limit_msg.Y_limit_left = 1;
  }
  else limit_msg.Y_limit_left = 0;

  
  
}


ros::Publisher chatter("limit_msg", &limit_msg);
ros::ServiceServer<xyInput::Request, xyInput::Response>server("xy_srv",&motor_callback);



void setup() {
  
  nh.initNode();
  nh.advertiseService(server);

  pinMode(y_mm,OUTPUT);  //for up and down(y)
  pinMode(y_d,OUTPUT);
  
  pinMode(x_mm,OUTPUT);  //for left and right(x)
  pinMode(x_d,OUTPUT);

  pinMode(y_limit_left,INPUT);  //Y_LIMIT_LEFT
  pinMode(y_limit_right,INPUT); //Y_LIMIT_RIGHT
  pinMode(x_limit_up,INPUT);    //X_LIMIT_UP
  pinMode(x_limit_down,INPUT);  //X_LIMIT_DOWN
  

}

void loop() {
  
  limit_switch();
  chatter.publish( &limit_msg );
  nh.spinOnce();
  delay(10);
}
